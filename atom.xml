<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>All Is Well</title>
  
  <subtitle>一切都是最好的安排</subtitle>
  <link href="https://hxs9712.github.io/atom.xml" rel="self"/>
  
  <link href="https://hxs9712.github.io/"/>
  <updated>2021-08-06T08:49:32.557Z</updated>
  <id>https://hxs9712.github.io/</id>
  
  <author>
    <name>破茧化蝶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义composer包步骤</title>
    <link href="https://hxs9712.github.io/2021/08/06/Composer/%E8%87%AA%E5%AE%9A%E4%B9%89composer%E5%8C%85/"/>
    <id>https://hxs9712.github.io/2021/08/06/Composer/%E8%87%AA%E5%AE%9A%E4%B9%89composer%E5%8C%85/</id>
    <published>2021-08-06T08:35:07.201Z</published>
    <updated>2021-08-06T08:49:32.557Z</updated>
    
    <content type="html"><![CDATA[<p>第一步，创建git仓库，把仓库clone到本地</p><p>第二步，进入本地仓库文件夹，执行composer init</p><p>第三步，根据命令行提示，填写基本信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#填写作者信息</span><br><span class="line">Author [zousi &lt;3056953305@qq.com&gt;, n to skip]: zousi &lt;3056953305@qq.com&gt;</span><br><span class="line">#定义包的稳定性，可用的稳定性标识（按字母排序）：dev、alpha、beta、RC、stable</span><br><span class="line">Minimum Stability []: dev</span><br><span class="line">#选择包类型</span><br><span class="line">Package Type (e.g. library, project, metapackage, composer-plugin) []: library</span><br><span class="line">#自定义许可证</span><br><span class="line">License []:</span><br><span class="line">#定义包需要的依赖</span><br><span class="line">Define your dependencies.</span><br><span class="line"></span><br><span class="line">Would you like to define your dependencies (require) interactively [yes]?</span><br><span class="line">#搜索需要的包</span><br><span class="line">Search for a package:</span><br><span class="line">#第二次确认</span><br><span class="line">Would you like to define your dev dependencies (require-dev) interactively [yes]?</span><br><span class="line">Search for a package:</span><br><span class="line">#确认json文件的基本信息</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;hsx9712&#x2F;composer_init&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;composer_init&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;library&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;zousi&quot;,</span><br><span class="line">            &quot;email&quot;: &quot;3056953305@qq.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;minimum-stability&quot;: &quot;dev&quot;,</span><br><span class="line">    &quot;require&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">#是否确认生成</span><br><span class="line">Do you confirm generation [yes]? yes</span><br><span class="line">#是否把vendor文件夹放到.gitignore文件中</span><br><span class="line">Would you like the vendor directory added to your .gitignore [yes]? yes</span><br></pre></td></tr></table></figure><p>创建完成。</p><p>第四步、提交到git远程仓库</p><p>第五步，复制git地址</p><p>第六步、打开<a href="https://packagist.org/%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E8%B4%A6%E5%8F%B7%EF%BC%8C%E5%85%88%E5%88%9B%E5%BB%BA%E8%B4%A6%E5%8F%B7">https://packagist.org/，如果没有账号，先创建账号</a></p><p>第七步、登录后点右上方的Submit按钮</p><p>第八步、在输入框粘贴git地址，并提交</p><p>完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一步，创建git仓库，把仓库clone到本地&lt;/p&gt;
&lt;p&gt;第二步，进入本地仓库文件夹，执行composer init&lt;/p&gt;
&lt;p&gt;第三步，根据命令行提示，填写基本信息，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="Composer" scheme="https://hxs9712.github.io/categories/Composer/"/>
    
    
    <category term="Composer" scheme="https://hxs9712.github.io/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="https://hxs9712.github.io/2021/08/06/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://hxs9712.github.io/2021/08/06/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2021-08-06T04:06:58.195Z</published>
    <updated>2021-08-10T01:53:37.321Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><p>redis为了防止宕机、停电等意外情况导致的数据丢失，便有了持久化的解决方案，具体有两种方式，RDB持久化和AOF持久化。</p><h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>RDB，全称Redis database，也就是redis数据库，顾名思义，这种持久化方式主要是以存储数据为主。简单来说，就是在一定时间内，进行了多少次操作，比如在15分钟内，进行了1000次操作，便将数据生成快照并存储到磁盘上，文件名默认为dump.rdb，恢复数据的时候就从磁盘上读出来。</p><h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><p>AOF，全称Append Only File，只能追加并且不可以改写的文件，只因为这个文件里存储的都是命令。简单来说，AOF就是每隔一定时间把命令存储到文件里，文件名默认为appendonly.aof，等到需要恢复数据的时候就重新执行一遍文件中的所有命令。</p><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><h5 id="RDB持久化方式分析"><a href="#RDB持久化方式分析" class="headerlink" title="RDB持久化方式分析"></a>RDB持久化方式分析</h5><p>1、RDB方式是将一段时间段内的数据快照持久化到磁盘中</p><p>2、RDB持久化过程中会先将数据存入到一个临时文件中，等快存完了，再用临时文件替换之前的持久化文件、以保证持久化文件完整性和可用性</p><p>3、RDB持久化时，Redis会单独fork一个子进程来处理，而主进程不需要进行任何IO操作，从而保证了Redis的高性能</p><p>4、RDB是每隔一段时间执行一次，这样的话就可能会造成数据丢失，比如每隔五分钟持久化一次，那就有可能丢失五分钟的数据，如果对数据的完整性不太重视，则适合用RDB这种持久化方式，因为它比AOF要高效</p><h5 id="AOF持久化方式分析"><a href="#AOF持久化方式分析" class="headerlink" title="AOF持久化方式分析"></a>AOF持久化方式分析</h5><p>1、AOF持久化策略是每秒钟执行一次，把指令记录到磁盘中，即使发生了宕机、停电等意外情况，也只会丢失1秒（官方说1秒，其实是要比1秒多的，）的数据，并且如果硬盘IO慢，会阻塞父进程</p><p>2、如果追加日志时，磁盘满了，或者其它意外情况导致日志不完整，redis提供了看redis-check-aof工具、可以修复日志</p><p>3、由于AOF文件只能追加、不能改写，文件便会随着时间的增长越来越大，因此，redis提供了AOF文件重写（rewrite）机制，当AOF文件大小超过配置的值时，redis便会压缩AOF文件，只保留可以恢复数据的指令。比如100个incr命令，合并成一条set指令，既能保证性能，也能压缩文件大小。<strong>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</strong></p><p>4、AOF持久化过程中也会先将数据存入到一个临时文件中，等快存完了，再用临时文件替换之前的持久化文件、以保证持久化文件完整性和可用性</p><p>5、如果AOF文件出现了问题，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p><p>1.备份被写坏的AOF文件<br>2.运行redis-check-aof –fix进行修复<br>3.用diff -u来看下两个文件的差异，确认问题点<br>4.重启redis，加载修复后的AOF文件</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到底是使用RDB还是AOF，Redis显然更高效，但是AOF显然可以更可靠的保证数据的完整性。至于选择RDB还是AOF，官方建议是两者同时用，这样可以最高能力保证数据的可靠性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Redis持久化&quot;&gt;&lt;a href=&quot;#Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化&quot;&gt;&lt;/a&gt;Redis持久化&lt;/h4&gt;&lt;p&gt;redis为了防止宕机、停电等意外情况导致的数据丢失，便有了持久化的解决方案，具体有两种方式</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>谷歌跨域设置</title>
    <link href="https://hxs9712.github.io/2021/06/07/Google/%E8%B0%B7%E6%AD%8C%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AE/"/>
    <id>https://hxs9712.github.io/2021/06/07/Google/%E8%B0%B7%E6%AD%8C%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-06-07T10:09:53.977Z</published>
    <updated>2021-06-07T10:12:11.721Z</updated>
    
    <content type="html"><![CDATA[<p>在“谷歌快捷方式—&gt;目标”后增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-web-security --user-data-dir&#x3D;C:\chromedata</span><br></pre></td></tr></table></figure><p>前边的空格不要忽略了；</p><p>整体是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; --disable-web-security --user-data-dir&#x3D;C:\chromedata</span><br></pre></td></tr></table></figure><p>前边路径以自己的为准，不用做修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在“谷歌快捷方式—&amp;gt;目标”后增加&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td </summary>
      
    
    
    
    <category term="其它" scheme="https://hxs9712.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="其它" scheme="https://hxs9712.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>重启后共享文件夹消失问题</title>
    <link href="https://hxs9712.github.io/2021/04/02/Vmware%20Tool/%E9%87%8D%E5%90%AF%E5%90%8E%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B6%88%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <id>https://hxs9712.github.io/2021/04/02/Vmware%20Tool/%E9%87%8D%E5%90%AF%E5%90%8E%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B6%88%E5%A4%B1%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-02T07:18:38.934Z</published>
    <updated>2021-04-02T07:23:12.340Z</updated>
    
    <content type="html"><![CDATA[<p>简单粗暴的解决办法，用以下命令新建一个共享目录（暂时还没有发现更好用的处理方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建文件夹</span><br><span class="line">mkdir &#x2F;mnt&#x2F;win</span><br><span class="line">2.把共享文件挂载到&#x2F;mnt&#x2F;win这个目录</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;vmhgfs-fuse .host:&#x2F; &#x2F;mnt&#x2F;win -o subtype&#x3D;vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure><p>这里有更详细的解释：<a href="https://blog.csdn.net/wangdonghao137/article/details/54925330">https://blog.csdn.net/wangdonghao137/article/details/54925330</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单粗暴的解决办法，用以下命令新建一个共享目录（暂时还没有发现更好用的处理方法）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</summary>
      
    
    
    
    <category term="虚拟机" scheme="https://hxs9712.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="虚拟机" scheme="https://hxs9712.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>禁止底层滚动</title>
    <link href="https://hxs9712.github.io/2021/03/30/MiniProgram/%E7%A6%81%E6%AD%A2%E5%BA%95%E5%B1%82%E6%BB%9A%E5%8A%A8/"/>
    <id>https://hxs9712.github.io/2021/03/30/MiniProgram/%E7%A6%81%E6%AD%A2%E5%BA%95%E5%B1%82%E6%BB%9A%E5%8A%A8/</id>
    <published>2021-03-30T11:01:55.264Z</published>
    <updated>2021-03-30T11:01:55.265Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myCatchTouch:function(e)&#123;</span><br><span class="line"></span><br><span class="line"> return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="微信小程序" scheme="https://hxs9712.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="https://hxs9712.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>windows家庭中文版安装Hyper-V</title>
    <link href="https://hxs9712.github.io/2021/03/30/Windows/windows%E5%AE%B6%E5%BA%AD%E4%B8%AD%E6%96%87%E7%89%88%E5%AE%89%E8%A3%85Hyper-V/"/>
    <id>https://hxs9712.github.io/2021/03/30/Windows/windows%E5%AE%B6%E5%BA%AD%E4%B8%AD%E6%96%87%E7%89%88%E5%AE%89%E8%A3%85Hyper-V/</id>
    <published>2021-03-30T10:50:07.431Z</published>
    <updated>2021-08-10T01:55:22.757Z</updated>
    
    <content type="html"><![CDATA[<p>1，新建记事本，放入一下代码，保存为Hyper-V.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir &#x2F;b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"></span><br><span class="line">for &#x2F;f %%i in (&#39;findstr &#x2F;i . hyper-v.txt 2^&gt;nul&#39;) do dism &#x2F;online &#x2F;norestart &#x2F;add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hyper-v.txt</span><br><span class="line"></span><br><span class="line">Dism &#x2F;online &#x2F;enable-feature &#x2F;featurename:Microsoft-Hyper-V-All &#x2F;LimitAccess &#x2F;ALL</span><br></pre></td></tr></table></figure><p>2，修改后缀名为cmd</p><p>3，以管理员身份运行Hyper-V.cmd</p><p>4，等待运行结束后，输入y，电脑会自动重启</p><p>5，电脑重启后，在开始的菜单栏里找到“Windows 管理工具—&gt;Hyper-V 管理器”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1，新建记事本，放入一下代码，保存为Hyper-V.txt&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="Windows" scheme="https://hxs9712.github.io/categories/Windows/"/>
    
    
    <category term="Windows" scheme="https://hxs9712.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理session失效问题解决</title>
    <link href="https://hxs9712.github.io/2021/03/22/Nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86session%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://hxs9712.github.io/2021/03/22/Nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86session%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2021-03-22T08:49:58.752Z</published>
    <updated>2021-03-22T08:49:58.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>最近遇到一个做单点登录的需求，我准备简单做，也就是账号之间的互绑，比如A网站的账号关联上B网站的账号，登录了A网站之后再去B网站可以免登录，我是用nginx反向代理来解决的。</p><p>刚开始我是这么配置的：</p><p> <code>location /aLogin &#123;</code>             </p><p>​    <code>proxy_pass   http://a.com/aLogin;</code></p><p><code>&#125;</code></p><p>通过浏览器访问<a href="http://a.com/aLogin%E6%97%B6%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84cookie%E5%86%85%E6%9C%89jsessionid%E3%80%82%E5%86%8D%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E5%8F%91%E9%80%81%E5%BD%93%E5%89%8D%E7%9A%84cookie%E3%80%82">http://a.com/aLogin时，浏览器的cookie内有jsessionid。再次访问时，浏览器会发送当前的cookie。</a></p><p> <code>location /bLogin &#123;</code>             </p><p>​    <code>proxy_pass   http://b.com/bLogin;</code></p><p><code>&#125;</code></p><h5 id="此时我们先回顾一下session的创建过程："><a href="#此时我们先回顾一下session的创建过程：" class="headerlink" title="此时我们先回顾一下session的创建过程："></a>此时我们先回顾一下session的创建过程：</h5><p>1、当浏览器第一次打开页面时，服务端会为这次会话创建一个session，并将session id通过response的header传递给浏览器，header一般为 Set-Cookie: JSESSIONID=xxxxx; Path=xxxx<br>2、浏览器接收到响应后，如果header Set-Cookie 中path的值与浏览器地址路径匹配，则将该header值存于浏览器的Cookie中<br>3、浏览器在下次请求服务器时，将Cookie中的JSESSIONID值通过request的header上报给服务端，header一般为 Cookie: JSESSIONID=xxxx;<br>4、服务端可通过该JSESSIONID来定位到对应的session</p><p>浏览器访问 <a href="http://a.com/aLogin">http://a.com/aLogin</a> 时，服务端返回的 <code>Set-Cookie</code> 的 Path 值为 /aLogin （因为中间有反向代理，服务端并不知道代理前的路径是啥，是按最终请求服务端的路径设置）</p><p>因为浏览器访问地址的路径 <code>/bLogin 与 </code>Set-Cookie<code>的 Path</code>/aLogin  不匹配，所以浏览器并不会将其值存入Cookie中。</p><p>因此在下次请求服务器时，浏览器无法设置request Cookie header的 JSESSIONID 值，服务器无法定位到对应的session，因此会将其当做第一次请求，创建一个新的session，如此反复，因此就算你登录认证通过了，但服务器返回的登录凭证（JSESSIONID）浏览器不会保存，并在下次请求时携带，导致服务器认为你是一个新的请求，当然就会又跳到登录页面了。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>nginx有一个命令 proxy_cookie_path（参考： proxy_cookie_path）可将服务器返回的 Set-Cookie 中的path进行修改，格式为 proxy_cookie_path 原路径 目标路径，我们在配置中添加 proxy_cookie_path 如下。</p><ol><li><pre><code class="nginx"> location /bLogin/ &#123;     proxy_pass  http://b.com/bLogin/;*     proxy_cookie_path  /aLogin /bLogin;//注意此处的对应路径顺序 &#125;</code></pre></li></ol><p>重启nginx，结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题场景&quot;&gt;&lt;a href=&quot;#问题场景&quot; class=&quot;headerlink&quot; title=&quot;问题场景&quot;&gt;&lt;/a&gt;问题场景&lt;/h3&gt;&lt;p&gt;最近遇到一个做单点登录的需求，我准备简单做，也就是账号之间的互绑，比如A网站的账号关联上B网站的账号，登录了A网站之后再去B</summary>
      
    
    
    
    <category term="Nginx" scheme="https://hxs9712.github.io/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://hxs9712.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理</title>
    <link href="https://hxs9712.github.io/2021/01/22/Nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://hxs9712.github.io/2021/01/22/Nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2021-01-22T10:34:06.760Z</published>
    <updated>2021-01-22T10:34:06.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><h4 id="什么叫反向代理？"><a href="#什么叫反向代理？" class="headerlink" title="什么叫反向代理？"></a>什么叫反向代理？</h4><p>反向代理就是用一个代理服务器代替用户转发请求到真实服务器，从而达到隐藏目标服务器的需求。</p><h4 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a>反向代理的用途</h4><p>动静分离，负载均衡都是基于反向代理来实现的。</p><p>示意图：</p><p><img src="/images/image-20210111190904926.png" alt="image-20210111190904926"></p><p>客户发送请求到代理服务器，服务器根据一定的标识符分发到目标服务器。</p><h3 id="反向代理实例"><a href="#反向代理实例" class="headerlink" title="反向代理实例"></a>反向代理实例</h3><p>下面是一个最基础的反向代理的配置，修改nginx.conf文件，增加一个server模块，主要配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">      #listen      443 ssl;</span><br><span class="line">        server_name  test.com alias test.com;</span><br><span class="line"></span><br><span class="line">                 location &#x2F; &#123;</span><br><span class="line">                            proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000;#目标服务器地址</span><br><span class="line">                 &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>浏览器访问：<a href="http://test.com,就可以得到http//127.0.0.1:3000%E7%9A%84%E5%86%85%E5%AE%B9%E4%BA%86%EF%BC%9B">http://test.com，就可以得到http://127.0.0.1:3000的内容了；</a></p><h4 id="怎么用一个服务器代理多台服务器"><a href="#怎么用一个服务器代理多台服务器" class="headerlink" title="怎么用一个服务器代理多台服务器"></a>怎么用一个服务器代理多台服务器</h4><p>上面我们学习的一个服务器只能代理一台服务器，那怎么才能代理多台服务器呢？下面是示意图：</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=924703378,2436109990&fm=26&gp=0.jpg" alt="img"></p><p>客户访问代理服务器，代理服务器根据不同的标识（规则）把请求分发到目标服务器，那这是怎么做到的呢？其实很简单，只需要用location去匹配相应的规则，便能达到分发请求的目的。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">      #listen      443 ssl;</span><br><span class="line">        server_name  test.com alias test.com;</span><br><span class="line"></span><br><span class="line">        location &#x2F;first &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:3000;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x2F;second &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:3001;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>可以看到，相较于上面的单台代理的配置文件，location部分发生了变化，这个变化也就是location用来匹配url的规则，此时，nginx会根据访问路径来分发请求给目标服务器；</p><p><a href="http://test.com/first">http://test.com/first</a> 会请求 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a></p><p><a href="http://test.com/second">http://test.com/second</a> 会请求 <a href="http://127.0.0.1:3001/">http://127.0.0.1:3001</a></p><p>location会根据域名后的字符来匹配相应的代理服务器</p><h4 id="location匹配规则（重点）"><a href="#location匹配规则（重点）" class="headerlink" title="location匹配规则（重点）"></a>location匹配规则（重点）</h4><p>语法规则：</p><p><img src="/images/image-20210113150828680.png" alt="image-20210113150828680"></p><p>location匹配规则主要有三种，并且它们的优先级如下：</p><p>1、精确匹配</p><p>2、正则匹配</p><p>3、通用匹配</p><p>注意：<em>location匹配规则与编写顺序无关</em></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">   #规则A</span><br><span class="line">&#125;</span><br><span class="line">location &#x3D; &#x2F;login &#123;</span><br><span class="line">   #规则B</span><br><span class="line">&#125;</span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;</span><br><span class="line">   #规则C</span><br><span class="line">&#125;</span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line">   #规则D</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.png$ &#123;</span><br><span class="line">   #规则E</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   #规则F</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这些规则同时存在的情况下，匹配优先级如下：</p><p>访问 <a href="http://localhost/">http://localhost/</a> 将匹配规则 A<br>访问 <a href="http://localhost/login">http://localhost/login</a> 将匹配规则 B，<a href="http://localhost/register">http://localhost/register</a> 则匹配规则 F<br>访问 <a href="http://localhost/static/a.html">http://localhost/static/a.html</a> 将匹配规则 C<br>访问 <a href="http://localhost/a.gif">http://localhost/a.gif</a>, <a href="http://localhost/b.jpg">http://localhost/b.jpg</a> 将匹配规则 D和规则 E，但是规则 D 顺序优先，规则 E不起作用，而 <a href="http://localhost/static/c.png%E5%88%99%E4%BC%98%E5%85%88%E5%8C%B9%E9%85%8D%E5%88%B0%E8%A7%84%E5%88%99">http://localhost/static/c.png则优先匹配到规则</a> C<br>访问 <a href="http://localhost/a.PNG">http://localhost/a.PNG</a> 则匹配规则 E，而不会匹配规则 D，因为规则 E 不区分大小写<br>访问 <a href="http://localhost/category/id/1111">http://localhost/category/id/1111</a> 则最终匹配到规则 F，因为以上规则都不匹配，这个时候应该是 nginx 转发请求给后端应用服务器，比如 FastCGI（PHP），tomcat（jsp），nginx 作为反向代理服务器存在</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;nginx反向代理&quot;&gt;&lt;a href=&quot;#nginx反向代理&quot; class=&quot;headerlink&quot; title=&quot;nginx反向代理&quot;&gt;&lt;/a&gt;nginx反向代理&lt;/h3&gt;&lt;h4 id=&quot;什么叫反向代理？&quot;&gt;&lt;a href=&quot;#什么叫反向代理？&quot; class=&quot;</summary>
      
    
    
    
    <category term="Nginx" scheme="https://hxs9712.github.io/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://hxs9712.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理--实际应用场景之动静分离（解决跨域问题）</title>
    <link href="https://hxs9712.github.io/2021/01/13/Nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86--%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B9%8B%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"/>
    <id>https://hxs9712.github.io/2021/01/13/Nginx/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86--%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B9%8B%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/</id>
    <published>2021-01-13T10:05:26.403Z</published>
    <updated>2021-01-14T04:01:37.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx反向代理–实际应用场景之动静分离（解决跨域问题）"><a href="#nginx反向代理–实际应用场景之动静分离（解决跨域问题）" class="headerlink" title="nginx反向代理–实际应用场景之动静分离（解决跨域问题）"></a>nginx反向代理–实际应用场景之动静分离（解决跨域问题）</h3><p>上一节我们熟悉了nginx反向代理的原理和基本配置，这节我们来进阶学习下nginx反向代理的应用场景。</p><h4 id="什么是动静分离（即前后端分离）"><a href="#什么是动静分离（即前后端分离）" class="headerlink" title="什么是动静分离（即前后端分离）"></a>什么是动静分离（即前后端分离）</h4><p>动静分离是将网站静态资源与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。</p><p>动静分离的一种做法是将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求全部请求nginx服务器，达到动静分离的目标。</p><h4 id="动静分离的好处"><a href="#动静分离的好处" class="headerlink" title="动静分离的好处"></a>动静分离的好处</h4><p>api接口服务化：动静分离之后，后端应用更为服务化，只需要通过提供api接口即可，可以为多个功能模块甚至是多个平台的功能使用，可以有效的节省后端人力，更便于功能维护。</p><p>前后端开发并行：前后端只需要关心接口协议即可，各自的开发相互不干扰，并行开发，并行自测，可以有效的提高开发时间，也可以有些的减少联调时间</p><p>减轻后端服务器压力，提高静态资源访问速度：后端不用再将模板渲染为html返回给用户端，且静态服务器可以采用更为专业的技术提高静态资源的访问速度。</p><h4 id="动静分离的简单实现"><a href="#动静分离的简单实现" class="headerlink" title="动静分离的简单实现"></a>动静分离的简单实现</h4><p>动静分离的实现实际上基于反向代理，主要配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">      #listen      443 ssl;</span><br><span class="line">        server_name  test.com alias test.com;</span><br><span class="line"></span><br><span class="line">#后端api</span><br><span class="line">location ^~ &#x2F;api &#123;</span><br><span class="line">        root 后端访问目录;</span><br><span class="line">        &#125;</span><br><span class="line">        #前端</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">        root 前端访问目录;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>此时访问<a href="http://test.com/api%E4%BE%BF%E4%BC%9A%E8%AF%B7%E6%B1%82%E5%88%B0">http://test.com/api便会请求到</a><u><em>后端访问目录</em></u>，</p><p>访问<a href="http://test.com便会请求到/">http://test.com便会请求到</a><u><em>前端访问目录</em></u></p><p>此配置方案也可用于解决前后端分离引起的跨域问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;nginx反向代理–实际应用场景之动静分离（解决跨域问题）&quot;&gt;&lt;a href=&quot;#nginx反向代理–实际应用场景之动静分离（解决跨域问题）&quot; class=&quot;headerlink&quot; title=&quot;nginx反向代理–实际应用场景之动静分离（解决跨域问题）&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Nginx" scheme="https://hxs9712.github.io/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://hxs9712.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>rand()查询效率问题解决</title>
    <link href="https://hxs9712.github.io/2020/07/17/Mysql/rand()%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://hxs9712.github.io/2020/07/17/Mysql/rand()%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2020-07-17T08:10:17.000Z</published>
    <updated>2021-08-10T05:04:48.388Z</updated>
    
    <content type="html"><![CDATA[<h6 id="随机从数据表中取一条数据，我们一般会用到rand（）函数，但是如果用不好的话，rand（）的效率实在太低。"><a href="#随机从数据表中取一条数据，我们一般会用到rand（）函数，但是如果用不好的话，rand（）的效率实在太低。" class="headerlink" title="随机从数据表中取一条数据，我们一般会用到rand（）函数，但是如果用不好的话，rand（）的效率实在太低。"></a>随机从数据表中取一条数据，我们一般会用到rand（）函数，但是如果用不好的话，rand（）的效率实在太低。</h6><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>SELECT * FROM tablename ORDER BY RAND() LIMIT 1</p><p>这是最基本的rand（）用法。</p><h3 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h3><p>我再表里加了一千万条测试数据。</p><p>select * from card order by rand() limit 1;</p><p>这条语句竟然用了23秒多（我的机子性能还算可以的了），这实在令人崩溃。后来去看了mysql官方手册，里边意思是在order by 从句中使用rand（）时，会导致数据列被多此扫描，所以效率会极低。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>后来在某社区发现了一个有趣的写法，先查出来表中最大的id，再查出来表中最小的id，然后两个id加起来，再用rand（）函数乘以加以来的结果，用floor函数向下取整，取出id大于这个这个整数的数据，用时0.002秒，跟之前那种写法简直是天壤之别。</p><p>SELECT * FROM <code>card</code><br>WHERE card_id &gt;= (SELECT FLOOR( RAND() *((SELECT MAX(card_id) FROM <code>card</code>)-(SELECT MIN(card_id) FROM <code>card</code>)) + (SELECT MIN(card_id) FROM <code>card</code>)))  ORDER BY card_id DESC;</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这里解释下为什么要用最大值，最小值相加的结果，而不用count函数，因为count算出来的结果不一定比最大的id大，这样的话随机出来的结果就会有瑕疵；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h6 id=&quot;随机从数据表中取一条数据，我们一般会用到rand（）函数，但是如果用不好的话，rand（）的效率实在太低。&quot;&gt;&lt;a href=&quot;#随机从数据表中取一条数据，我们一般会用到rand（）函数，但是如果用不好的话，rand（）的效率实在太低。&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Mysql" scheme="https://hxs9712.github.io/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://hxs9712.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务和Mysql事务的却别</title>
    <link href="https://hxs9712.github.io/2020/05/23/Redis/Redis%E4%BA%8B%E5%8A%A1%E5%92%8CMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://hxs9712.github.io/2020/05/23/Redis/Redis%E4%BA%8B%E5%8A%A1%E5%92%8CMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2021-08-10T09:51:40.184Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h5><p>默认状态未开启，执行步骤：</p><ol><li>multi 开启事务</li><li>exec 执行事务</li><li>discard 取消事务</li></ol><p>特点：</p><ul><li>单独的隔离操作，事务会按照顺序执行，不会被客户端的其它请求干扰</li><li>由于redis的事务只是把命令放到了队列里，并没有执行，而是等到最后一起执行，从而事务间就不会导致数据脏读、不可重复读、幻读的问题，所以也就没有隔离级别的概念</li><li>执行事务时，如果有语法错误，事务不会执行</li><li>不具备原子性，执行事务时，如果有命令执行失败，事务会继续执行，不会执行回滚操作，不会影响后续的操作</li></ul><h5 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h5><p>默认开启事务，每次语句执行都会开启事务，执行步骤：</p><ol><li>begin 显示的开启事务</li><li>commit 提交事务，执行语句</li><li>rollback 取消事务，进行回滚操作，撤销所有更改</li></ol><p>特点：</p><ul><li>原子性，一个事务中的操作，要么全部完成，要么全部失败，只要执行中发生错误，就会被回滚到事务执行前的状态。</li><li>一致性，在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li>隔离性，数据库允许多个并发事务同时对数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>持久性，事务处理结束后，对数据的修改是永久的，即使系统故障也不会丢失</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;Redis事务&quot;&gt;&lt;a href=&quot;#Redis事务&quot; class=&quot;headerlink&quot; title=&quot;Redis事务&quot;&gt;&lt;/a&gt;Redis事务&lt;/h5&gt;&lt;p&gt;默认状态未开启，执行步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;multi 开启事务&lt;/li&gt;
&lt;li&gt;exe</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>哨兵模式详解</title>
    <link href="https://hxs9712.github.io/2020/05/22/Redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hxs9712.github.io/2020/05/22/Redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-21T16:00:00.000Z</published>
    <updated>2021-08-11T10:55:22.560Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>哨兵，也可以理解为巡逻兵，当发现敌情的时候，会报告给总部，然后总部来处理敌情。</p><p>所以，哨兵模式也就是有一个单独执行的任务，这个任务就一直盯着主机，一旦主机挂掉，就立马通知从机，然后从机通过选举的方式，选出一个得票最高的从机来担任主机。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>新建一个哨兵的配置文件，随便起一个名字，比如sentinel.conf，在文件中写入一行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mySentinel 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><h5 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h5><p>sentinel monitor 哨兵监视</p><p>mySentinel 自定义哨兵名字</p><p>127.0.0.1 6379 需要被监视的主机ip和端口</p><p>1 指明当有多少个sentinel认为一个master失效时，master才算真正失效，此处为1个</p><h4 id="哨兵启动"><a href="#哨兵启动" class="headerlink" title="哨兵启动"></a>哨兵启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel &#x2F;path&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>/path/sentinel.conf应该用你自己真实的路径和文件名</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>可以自动重新指定新的主机，以保证系统继续正常运行</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>哨兵是有延时的，选举新主机也是有延时，还是会造成系统暂时性的瘫痪</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;哨兵，也可以理解为巡逻兵，当发现敌情的时候，会报告给总部，然后总部来处理敌情。&lt;/p&gt;
&lt;p&gt;所以，哨兵模式也就是有一个单独</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>主从复制详解</title>
    <link href="https://hxs9712.github.io/2020/05/21/Redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hxs9712.github.io/2020/05/21/Redis/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-20T16:00:00.000Z</published>
    <updated>2021-08-11T10:35:31.833Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis主从复制，顾名思义，把主机的数据复制到从机，主机用来写入数据，从机用来读取数据，从而达到读写分离的效果，目的是减轻主机的读取压力，提升系统性能。</p><h4 id="思考一"><a href="#思考一" class="headerlink" title="思考一"></a>思考一</h4><p>既然是主从复制，那就肯定需要至少两台机子，才能实现一主一仆的效果，那也就是说需要启动两个redis服务，怎么才能做到启动两个redis服务呢？</p><p>既然有主有仆，那么怎么指定主机和从机呢？</p><p>既然从机是用来读取数据的，那么从机是否可以写入数据呢？</p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><h5 id="1、开启多个redis服务的方法"><a href="#1、开启多个redis服务的方法" class="headerlink" title="1、开启多个redis服务的方法"></a>1、开启多个redis服务的方法</h5><p>redis有一个默认配置文件redis.conf,文件里的默认端口号是6379，而redis启动就是根据配置文件中的ip和端口号来启动的。所以我们要做的就是复制redis.conf，并改为redis6380.conf，并修改文件中的端口为6380，然后给6380配置对应的数据存储文件dump6380.rdb，对应的日志文件6380.log，对应的Pid文件，6379.pid，那么启动时，如果指定加载redis6380.conf，那么就相当于在6380端口又开启了一个redis服务，同样，也可以此方法开启6381、6382等多个redis服务。</p><h5 id="2、指定主机和从机"><a href="#2、指定主机和从机" class="headerlink" title="2、指定主机和从机"></a>2、指定主机和从机</h5><p>先启动6379和6380服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#把6379作为主机并写入值</span><br><span class="line">127.0.0.1:6379&gt; set a a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication #查看本机信息</span><br><span class="line"># Replication</span><br><span class="line">role:master #角色为master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;1065,lag&#x3D;1</span><br><span class="line">master_repl_offset:1079</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:1078</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">#用SLAVEOF命令把6380作为6379的从机</span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">127.0.0.1:6380&gt; get a</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6380&gt; set b b</span><br><span class="line">(error) READONLY You can&#39;t write against a read only replica. #会提示从机只能读取数据，不可以写入</span><br><span class="line">127.0.0.1:6380&gt; info replication #查看本机信息</span><br><span class="line"># Replication</span><br><span class="line">role:slave #角色为slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:1009</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:f101754c767cd8062df60d3b53bd0fa1c96aeee5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1009</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:814</span><br><span class="line">repl_backlog_histlen:196</span><br><span class="line">127.0.0.1:6380&gt;</span><br></pre></td></tr></table></figure><h6 id="可以看到6380已经读到了主机的数据，此时如果继续在6379上写入数据的话，数据会继续同步到6380，并且在从机上是无法写入数据的"><a href="#可以看到6380已经读到了主机的数据，此时如果继续在6379上写入数据的话，数据会继续同步到6380，并且在从机上是无法写入数据的" class="headerlink" title="可以看到6380已经读到了主机的数据，此时如果继续在6379上写入数据的话，数据会继续同步到6380，并且在从机上是无法写入数据的"></a>可以看到6380已经读到了主机的数据，此时如果继续在6379上写入数据的话，数据会继续同步到6380，并且在从机上是无法写入数据的</h6><h4 id="思考二"><a href="#思考二" class="headerlink" title="思考二"></a>思考二</h4><p>如果主机突然宕机挂掉了，从机会变为主机吗？</p><p>如果主机又重启了，从机还能继续联系上主机吗？</p><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><p>如果主机挂掉了，从机会进入等待状态，只要主机重启，从机会联系上主机继续运作。</p><h4 id="思考三"><a href="#思考三" class="headerlink" title="思考三"></a>思考三</h4><p>如果主机挂掉了，会导致系统无法正常运行，此时怎么才能指定一台新的主机，从而保证系统的正常运行？</p><h4 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h4><ol><li>用slaveof命令手动指定一台从机变为主机（不推荐），这种做法不够现实，人不可能一天24小时盯着系统，并且如果redis集群过多，操作也会比较繁琐。</li><li>利用哨兵模式，自动的选举出一台从机变为主机（<a href="https://hxs9712.github.io/2021/08/06/Redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/">哨兵模式详解</a>）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis主从复制，顾名思义，把主机的数据复制到从机，主机用来写入数据，从机用来读取数据，从而达到读写分离的效果，目的是减轻</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁</title>
    <link href="https://hxs9712.github.io/2020/05/20/Redis/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <id>https://hxs9712.github.io/2020/05/20/Redis/%E4%B9%90%E8%A7%82%E9%94%81/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2021-08-10T08:39:17.611Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis的乐观锁主要用watch命令实现，当watch命令监视某个值的时候，那么事务在执行之前就会检测该值是否已发生改变，如果在事务执行前该值已被修改，则事务不会执行。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#情况一，money值未在事务执行之前发生改变，事务正常执行</span><br><span class="line">127.0.0.1:6379&gt; set money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br><span class="line"></span><br><span class="line">#情况二，money值在事务执行之前发生改变，事务正常执行</span><br><span class="line">##客户端1</span><br><span class="line">###监听m值并开启事务，此处还未执行事务</span><br><span class="line">127.0.0.1:6379&gt; set m 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch m</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby m 20</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##客户端2</span><br><span class="line">###修改m值</span><br><span class="line">127.0.0.1:6379&gt; set m 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">##客户端1</span><br><span class="line">###执行事务会失败，返回nil</span><br><span class="line">127.0.0.1:6379&gt; exec #此时会比较m值是否已经被修改</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; unwatch #此时需要取消监听</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch m #从新监听m值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi #重新开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby m 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec #事务正常执行</span><br><span class="line">1) (integer) -20</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis的乐观锁主要用watch命令实现，当watch命令监视某个值的时候，那么事务在执行之前就会检测该值是否已发生改变，</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="https://hxs9712.github.io/2020/05/20/Redis/%E4%BA%8B%E5%8A%A1/"/>
    <id>https://hxs9712.github.io/2020/05/20/Redis/%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2021-08-10T08:11:35.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis事务可以一次执行多个命令，主要有以下三个步骤：</p><p>（1）multi，开启事务</p><p>（2）把命令全部存入队列中</p><p>（3）exce，执行队列中的所有命令</p><p>有三个特点：</p><p>（1）在exce执行命令前，所有命令会被放入队列缓存</p><p>（2）如果执行命令中，有命令执行失败，其它的命令会继续执行，不受影响，但如果是语法错误，则所有命令都不会执行</p><p>（3）在事务执行过程中，其它客户端提交的命令请求无法插入到事务执行命令序列中</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#语法错误</span><br><span class="line">127.0.0.1:6379&gt; MULTI #开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set a a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; sadd name zhangsan lisi</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key #此处语法错误</span><br><span class="line">(error) ERR unknown command &#96;smem&#96;, with args beginning with:</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec #语法错误，事务无法正常执行，会报错</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"></span><br><span class="line">#正常情况</span><br><span class="line">127.0.0.1:6379&gt; multi #开启事务</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set a a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; sadd name zhangsan lisi</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec #正常执行</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) (integer) 2</span><br><span class="line">4) 1) &quot;zhangsan&quot;</span><br><span class="line">   2) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">#命令执行失败情况</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set a a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr a #此处a不是整数，无法进行加减操作，会失败，但不会影响后边两个命令的执行</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set b b</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get b</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) (error) ERR value is not an integer or out of range</span><br><span class="line">4) OK</span><br><span class="line">5) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis事务可以一次执行多个命令，主要有以下三个步骤：&lt;/p&gt;
&lt;p&gt;（1）multi，开启事务&lt;/p&gt;
&lt;p&gt;（2）把命</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>GEO详解</title>
    <link href="https://hxs9712.github.io/2020/05/20/Redis/GEO%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hxs9712.github.io/2020/05/20/Redis/GEO%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-19T16:00:00.000Z</published>
    <updated>2021-08-11T08:05:16.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis GEO主要用于管理地理信息，比如储存位置坐标，计算距离，获取指定范围内的地理位置信息。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd location 121.47939 31.229012 shanghai 121.431097 31.229506 changning #添加位置及坐标信息到location中</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; geodist location shanghai changning #计算两地距离，默认单位m</span><br><span class="line">&quot;4593.2133&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist location shanghai changning km #计算两地距离，单位km</span><br><span class="line">&quot;4.5932&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist location shanghai changning m </span><br><span class="line">&quot;4593.2133&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS location 121.431097 31.229506 5 km #根据坐标查询5公里范围内的地址</span><br><span class="line">1) &quot;changning&quot;</span><br><span class="line">2) &quot;shanghai&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS location 121.431097 31.229506 5 km withcoord #根据坐标查询5公里范围内的地址并显示距离</span><br><span class="line">1) 1) &quot;changning&quot;</span><br><span class="line">   2) 1) &quot;121.43109887838364&quot;</span><br><span class="line">      2) &quot;31.229504769131758&quot;</span><br><span class="line">2) 1) &quot;shanghai&quot;</span><br><span class="line">   2) 1) &quot;121.47938936948776&quot;</span><br><span class="line">      2) &quot;31.229013033226856&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS location 121.431097 31.229506 5 km withcoord withdist#根据坐标查询5公里范围内的地址并显示坐标及距离</span><br><span class="line">1) 1) &quot;changning&quot;</span><br><span class="line">   2) &quot;0.0002&quot;</span><br><span class="line">   3) 1) &quot;121.43109887838364&quot;</span><br><span class="line">      2) &quot;31.229504769131758&quot;</span><br><span class="line">2) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;4.5934&quot;</span><br><span class="line">   3) 1) &quot;121.47938936948776&quot;</span><br><span class="line">      2) &quot;31.229013033226856&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS location 121.431097 31.229506 5 km withcoord withdist withhash #根据坐标查询5公里范围内的地址并显示坐标、距离及哈希值</span><br><span class="line">1) 1) &quot;changning&quot;</span><br><span class="line">   2) &quot;0.0002&quot;</span><br><span class="line">   3) (integer) 4054756175604982</span><br><span class="line">   4) 1) &quot;121.43109887838364&quot;</span><br><span class="line">      2) &quot;31.229504769131758&quot;</span><br><span class="line">2) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;4.5934&quot;</span><br><span class="line">   3) (integer) 4054757658121850</span><br><span class="line">   4) 1) &quot;121.47938936948776&quot;</span><br><span class="line">      2) &quot;31.229013033226856&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos location shanghai changning #查询地址的坐标</span><br><span class="line">1) 1) &quot;121.47938936948776&quot;</span><br><span class="line">   2) &quot;31.229013033226856&quot;</span><br><span class="line">2) 1) &quot;121.43109887838364&quot;</span><br><span class="line">   2) &quot;31.229504769131758&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER location shanghai 5 km #根据地址查询5公里范围内的地址</span><br><span class="line">1) &quot;shanghai&quot;</span><br><span class="line">2) &quot;changning&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEOHASH location shanghai changning #获取一个或者多个位置的哈希值</span><br><span class="line">1) &quot;wtw3sm4d4v0&quot;</span><br><span class="line">2) &quot;wtw3ejpmj90&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis GEO主要用于管理地理信息，比如储存位置坐标，计算距离，获取指定范围内的地理位置信息。&lt;/p&gt;
&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>发布与订阅</title>
    <link href="https://hxs9712.github.io/2020/05/19/Redis/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/"/>
    <id>https://hxs9712.github.io/2020/05/19/Redis/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/</id>
    <published>2020-05-18T16:00:00.000Z</published>
    <updated>2021-08-10T07:25:28.606Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis发布与订阅消息是一种通信模式，就相当于报社发布报纸，送给订阅报纸的人们一样。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h5 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#发布端</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH msg hello #发布hello信息到msg频道上</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line">#订阅端</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE msg #订阅msg这个频道，一旦有消息推送到msg频道便会立马接收过来</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;msg&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;msg&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBSUB CHANNELS #查看当前活跃的频道列表</span><br><span class="line">1) &quot;msg&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; PUNSUBSCRIBE m* #退订所有m开头的频道</span><br><span class="line">1) &quot;punsubscribe&quot;</span><br><span class="line">2) &quot;m*&quot;</span><br><span class="line">3) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; UNSUBSCRIBE msg #退订指定频道</span><br><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) &quot;msg&quot;</span><br><span class="line">3) (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE msg msg1 #订阅多个频道</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;msg&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;msg1&quot;</span><br><span class="line">3) (integer) 2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis发布与订阅消息是一种通信模式，就相当于报社发布报纸，送给订阅报纸的人们一样。&lt;/p&gt;
&lt;h4 id=&quot;命令&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>HyperLogLog详解</title>
    <link href="https://hxs9712.github.io/2020/05/18/Redis/HyperLogLog%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hxs9712.github.io/2020/05/18/Redis/HyperLogLog%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-17T16:00:00.000Z</published>
    <updated>2021-08-10T07:10:10.856Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis HyperLogLog是用来做基数统计的算法</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>当输入元素的数量或者体积非常非常大时，计算基数只需要占用很小的空间即可完成。每个HyperLogLog键只需要花费12kb内存，就可以计算接近2^64个不同元素的基数，这和计算基数时，元素越多耗费内存越大的集合形成鲜明对比。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>因为HyperLogLog只会根据元素来统计基数，而不会存入元素本身，所以不能像集合那样，返回各个元素。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd test 1 1 1 2 2 3 4 5 5 #添加一个或多个元素到HyperLogLog中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT test #统计基数，只统计不同的元素</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd test2 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE test3 test2 test #将多个HyperLogLog合并为一个HyperLogLog</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount test3</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis HyperLogLog是用来做基数统计的算法&lt;/p&gt;
&lt;h5 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; cla</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Set集合类型详解</title>
    <link href="https://hxs9712.github.io/2020/05/17/Redis/Set%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hxs9712.github.io/2020/05/17/Redis/Set%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2021-08-10T02:59:27.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>集合对象的编码可以是 intset 或者 hashtable。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd name xiaoming zhangsan lisi wanger #添加一个或者多个元素到集合中</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name #查看所有元素</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;wanger&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">4) &quot;xiaoming&quot;</span><br><span class="line">127.0.0.1:6379&gt; SCARD name #获取列表中有多个元素</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd name2 zhangsan mazi #添加一个或者多个元素到集合中</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; SDIFF name name2 #获取两个或者多个集合的差集</span><br><span class="line">1) &quot;wanger&quot;</span><br><span class="line">2) &quot;xiaoming&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFFSTORE name3 name name2 #把集合的差集存储到另一个集合中</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name3</span><br><span class="line">1) &quot;wanger&quot;</span><br><span class="line">2) &quot;xiaoming&quot;</span><br><span class="line">3) &quot;lisi&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter name name2 #获取两个或者多个集合的交集</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt; SINTERSTORE name4 name name2 #把集合的交集存储到另一个集合中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name4</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER name maike #判断元素是否存在于集合中</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER name wanger</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smove name name5 lisi #把一个元素从一个集合中移动到另一个集合中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; spop name #移除并返回集合中的随机一个元素</span><br><span class="line">&quot;wanger&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER name #返回集合中一个或者多个随机数</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER name 2</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;xiaoming&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION name name2 #返回两个或者多个集合的并集</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;mazi&quot;</span><br><span class="line">3) &quot;xiaoming&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNIONSTORE name6 name name2 #把并集存到另一个集合中</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name6</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;mazi&quot;</span><br><span class="line">3) &quot;xiaoming&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;xiaoming&quot;</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS name2</span><br><span class="line">1) &quot;zhangsan&quot;</span><br><span class="line">2) &quot;mazi&quot;</span><br><span class="line">127.0.0.1:6379&gt; SSCAN name 0 z* #根据表达式规则匹配集合中的元素并返回</span><br><span class="line">(error) ERR syntax error</span><br><span class="line">127.0.0.1:6379&gt; SSCAN name 0 match z*</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>有序集合类型详解</title>
    <link href="https://hxs9712.github.io/2020/05/17/Redis/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hxs9712.github.io/2020/05/17/Redis/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2021-08-10T06:25:30.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h4><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><p> 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd car 1 stn 2 xtl 4 bm 3 bc #添加一个或者多个到有序集合中</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE car 0 -1 withscores #获取集合元素及分数</span><br><span class="line">1) &quot;stn&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;xtl&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;bc&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;bm&quot;</span><br><span class="line">8) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZCARD car #统计元素个数</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT car 3 4 #获取分数区间的元素个数</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY car 4 bm #给元素增加分数</span><br><span class="line">&quot;8&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE car 0 -1 withscores #获取集合元素及分数</span><br><span class="line">1) &quot;stn&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;xtl&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;bc&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;bm&quot;</span><br><span class="line">8) &quot;8&quot;</span><br><span class="line">127.0.0.1:6379&gt; zadd car2 10 lsls </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE car3 2 car car2 #把两个集合的交集存到另一个集合中</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd car2 10 lsls 11 bm </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE car3 2 car car2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE car3 0 0 </span><br><span class="line">1) &quot;bm&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE car3 0 0 withscores</span><br><span class="line">1) &quot;bm&quot;</span><br><span class="line">2) &quot;19&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE car (3 8 #获取分数区间的元素，(3代表大于3，8代表小于等于8</span><br><span class="line">1) &quot;bm&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE car (3 8 withscores</span><br><span class="line">1) &quot;bm&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE car (1 8 withscores</span><br><span class="line">1) &quot;xtl&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;bc&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;bm&quot;</span><br><span class="line">6) &quot;8&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE car -inf +inf withscores #获取所有元素，并按照分数排序</span><br><span class="line">1) &quot;stn&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;xtl&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;bc&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line">7) &quot;bm&quot;</span><br><span class="line">8) &quot;8&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE car -inf +inf</span><br><span class="line">1) &quot;stn&quot;</span><br><span class="line">2) &quot;xtl&quot;</span><br><span class="line">3) &quot;bc&quot;</span><br><span class="line">4) &quot;bm&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange car 0 0</span><br><span class="line">1) &quot;stn&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange car 0 -1</span><br><span class="line">1) &quot;stn&quot;</span><br><span class="line">2) &quot;xtl&quot;</span><br><span class="line">3) &quot;bc&quot;</span><br><span class="line">4) &quot;bm&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrank car stn #获取指定元素的排名（按照分数排名）</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrank car xtl</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrem car stn xtl #移除指定元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK car 0 7 #根据排名移除区间内元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE car 0 -1</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt; zadd car 1 stn 2 xtl 3 bm</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE car 1 2 #移除指定分数区间内元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd car 6 bsj 7 fll 9 lsls</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE car 0 3 #获取指定索引区间内的以分数排名的元素</span><br><span class="line">1) &quot;lsls&quot;</span><br><span class="line">2) &quot;fll&quot;</span><br><span class="line">3) &quot;bsj&quot;</span><br><span class="line">4) &quot;bm&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE car 0 2</span><br><span class="line">1) &quot;lsls&quot;</span><br><span class="line">2) &quot;fll&quot;</span><br><span class="line">3) &quot;bsj&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE car 9 6 #获取指定分数区间内以分数排名的元素</span><br><span class="line">1) &quot;lsls&quot;</span><br><span class="line">2) &quot;fll&quot;</span><br><span class="line">3) &quot;bsj&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK car fll #获取指定元素排名</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK car lsls</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK car bm</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore car bm #获取元素分数</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内容简介&quot;&gt;&lt;a href=&quot;#内容简介&quot; class=&quot;headerlink&quot; title=&quot;内容简介&quot;&gt;&lt;/a&gt;内容简介&lt;/h4&gt;&lt;p&gt;Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。&lt;/p&gt;
&lt;p&gt;不同的是每个元素都会关</summary>
      
    
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://hxs9712.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
